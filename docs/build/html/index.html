

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Welcome to QSM’s documentation! &mdash; QSM 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> QSM
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Welcome to QSM’s documentation!</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#setup">Setup</a></li>
<li><a class="reference internal" href="#layout">Layout</a></li>
<li><a class="reference internal" href="#simulation">Simulation</a></li>
<li><a class="reference internal" href="#calculation">Calculation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#details">Details</a><ul>
<li><a class="reference internal" href="#id1">Layout</a></li>
<li><a class="reference internal" href="#simulations-calculations">Simulations/Calculations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#license">License</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">QSM</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>Welcome to QSM’s documentation!</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="welcome-to-qsm-s-documentation">
<h1>Welcome to QSM’s documentation!<a class="headerlink" href="#welcome-to-qsm-s-documentation" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>The Qubit Simulation Module (QSM) is a software package that facilitates the full design process for
superconducting qubits and resonators. It is designed to be highly modular and accommodate any user-defined models,
but by default it uses those found in Chapter 4 of Junling Long’s doctoral thesis found
<a class="reference external" href="https://sites.google.com/view/junlings-research-homepage/thesis?authuser=0">here</a>.</p>
<p>It is written in Python with external calls to the Ansys HFSS, Q3D, and Nexxim simulators.</p>
<p>Two examples are included for reference.</p>
</div>
<div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<p>The QSM partitions the design process into two sequential phases: “Layout” and “Simulation/Calculation”.
In the ‘layout’ phase, the user defines the geometry of their system, along with some basic properties such as
qubit inductance and CPW phase velocity.
In the ‘simulation/calculation’ phase they run various analyses based on the layout.
‘Simulations’ are analyses sufficiently complex to warrant saving the
results to data files for later use (includes all Ansys simulations, system quantization, and generally anything
involving matrix inversions), and ‘calculations’ are faster analyses that don’t require saving. Note that both
simulations and calculations can be dependent on the results of other simulations/calculations, so the user needs to pay
careful attention to the order in which analyses are run.</p>
<p>The QSM user interface is a python script in which the user creates a qSysLayout object, then passes that object as
a parameter into their desired simulations/calculations.</p>
<div class="section" id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h2>
<p>To use the QSM the user needs to have a python 3 environment with the following installed:</p>
<ul class="simple">
<li><p>numpy</p></li>
<li><p>gdspy</p></li>
<li><p>sympy</p></li>
<li><p>shapely</p></li>
<li><p>matplotlib</p></li>
<li><p>pathlib</p></li>
</ul>
<p>To begin a design, make a fresh directory containing the template version of “driver.py” (found in the source
directory). In the header there is a variable called “computeLocation”. This is used to differentiate between running
the QSM on a single Windows workstation (“Windows”) and running it on a cluster (“Cluster”).</p>
<p>Regardless of computeLocation, the variable “QSMSourceFolder” needs to be appropriately set. Nothing else in the header
needs to be touched by the user.</p>
</div>
<div class="section" id="layout">
<h2>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h2>
<p>Once the design directory is set up, the the user needs to generate and populate the following three layout files:</p>
<ul class="simple">
<li><p>systemParameters.json</p></li>
<li><p>componentParameters.json</p></li>
<li><p>componentGeometries.json</p></li>
</ul>
<p>systemParams is generated via adding the following to driver.py:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QSM</span><span class="o">.</span><span class="n">generateSystemParams</span><span class="p">(</span><span class="n">projectFolder</span><span class="p">)</span>
</pre></div>
</div>
<p>The user then navigates to the design directory and runs driver.py, generating systemParameters.json.
Note that moving forward this process of entering a line into driver.py then running it will just be referred to as
“running a command”.</p>
<p>Once systemParameters is generated the user needs to populate it with the numbers of each elements, along with various
other values.</p>
<p>Now that the system information is set, the qSysLayout object can be created. This is achieved via the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qSys</span> <span class="o">=</span> <span class="n">QSM</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">projectFolder</span><span class="p">,</span> <span class="n">computeLocation</span><span class="p">,</span> <span class="n">QSMSourceFolder</span><span class="p">,</span> <span class="n">layoutCompleted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>For all subsequent runs of driver.py this must be the first line after the header</strong>. The only part of this line the
user needs to modify is layoutCompleted, which should remain false until the end of the layout phase.</p>
<p>Once systemParameters is populated, the user needs to generate and populate componentParameters.json. These are more
detailed inquiries about the various elements of the system. This is accomplished by running:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qSys</span> <span class="o">=</span> <span class="n">QSM</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">projectFolder</span><span class="p">,</span> <span class="n">computeLocation</span><span class="p">,</span> <span class="n">QSMSourceFolder</span><span class="p">,</span> <span class="n">layoutCompleted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">qSys</span><span class="o">.</span><span class="n">generateComponentParams</span><span class="p">()</span>
</pre></div>
</div>
<p>On populating componentParams the user needs to generate and populate componentGeometries.json via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qSys</span> <span class="o">=</span> <span class="n">QSM</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">projectFolder</span><span class="p">,</span> <span class="n">computeLocation</span><span class="p">,</span> <span class="n">QSMSourceFolder</span><span class="p">,</span> <span class="n">layoutCompleted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">qSys</span><span class="o">.</span><span class="n">generateGeometries</span><span class="p">()</span>
</pre></div>
</div>
<p>Once all three layout files are populated the user can generate the layout GDS via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qSys</span><span class="o">.</span><span class="n">generateGDS</span><span class="p">(</span><span class="n">addMesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">invertGDS</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, the user switches layoutCompleted to True and can begin running analyses.</p>
</div>
<div class="section" id="simulation">
<h2>Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline">¶</a></h2>
<p>Simulations are classes found in simulations.py, and are used via instantiated objects taking qSys as their
sole argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myFooSim</span> <span class="o">=</span> <span class="n">FooSim</span><span class="p">(</span><span class="n">qSys</span><span class="p">)</span>
</pre></div>
</div>
<p>Methods of this object then perform the various stages of the simulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myFooSim</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span> <span class="c1"># Creates the simulation directory and parameters file that requires user input</span>
<span class="n">myFooSim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span> <span class="c1"># Runs all associated ansys simulations</span>
<span class="n">myFooSim</span><span class="o">.</span><span class="n">postProcess</span><span class="p">()</span> <span class="c1"># Runs all post processing steps once the ansys simulations are completed.</span>
</pre></div>
</div>
<p>Note that because initialize() is typically followed by user input, and postProcess() can only be run once all
Ansys simulations are completed (which may be asynchronously computed on a cluster), the above commands are typically
run <em>one at a time</em>.</p>
<p>QSM comes with many built-in simulations for carrying out the NIST models. These simulations share the common
characteristic of not modifying the qSys object. For simulations that require results from other simulations, the
associated simulation objects are created and their results read. For example, the Quantize simulation requires the
output of CapMatGE, so CapMatGE has the getter function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CapMatGE</span><span class="p">(</span><span class="n">qSys</span><span class="p">)</span><span class="o">.</span><span class="n">CapMatGE</span>
</pre></div>
</div>
<p>that returns the simulated value, and Quantize will call that getter to access the value. In this way the qSys object
remains completely decoupled from the simulations, only ever containing layout information. While this is not a
forced paradigm, it is recommended from an extensibility standpoint.</p>
</div>
<div class="section" id="calculation">
<h2>Calculation<a class="headerlink" href="#calculation" title="Permalink to this headline">¶</a></h2>
<p>Because calculations do not involve ansys or cluster simulations, they are methods rather than classes.
They are simply called e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">anharmonicityQCalc</span><span class="p">(</span><span class="n">qSys</span><span class="p">,</span> <span class="n">q1Index</span><span class="p">,</span> <span class="n">q2Index</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="details">
<h1>Details<a class="headerlink" href="#details" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>Layout<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Some fields in the layout files require specific input. The current available options are:</p>
<ul>
<li><p>systemParameters</p>
<ul class="simple">
<li><p>Material -&gt; perfector conductor, aluminum, etc. -&gt; see Ansys material list.</p></li>
<li><p>Flip Chip?, Simulate Feedline? -&gt; Yes, No</p></li>
<li><p>Chip Markers -&gt; Pappas, Schmidt</p></li>
<li><p>Simulation -&gt; 2D,3D</p></li>
</ul>
</li>
<li><p>componentParameters</p>
<ul>
<li><p>Qubit Type: {Floating,Grounded}-rectangularPads-{single,double}JJ i.e. Floating-rectangularPads-singleJJ</p></li>
<li><p>Resonator/Qubit indices: Qubit/Readout resonator pairs <strong>must share the same index</strong>. Furthermore, the resonators
<strong>must be numbered according to their position along the feedline</strong>, with 0 being the left-most (for a straight unrotated feedline).
This is so the simulation knows how to model the feedline as a series of transmission lines of various lengths.</p></li>
<li><p>Resonator Pad Type: T</p></li>
<li><p>Control line type:</p>
<blockquote>
<div><ul class="simple">
<li><p>“feedline”: Launch pad at both ends. <strong>There can be at most one feedline and if it exists it must be index 0</strong></p></li>
<li><p>“fluxBias”: grounded flux bias, launch pad at only one end.</p></li>
<li><p>“drive”: Launch pad at just one end.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</li>
<li><p>componentGeometries: Most of these definitions can be found in the “GeometryParameters” powerpoint. A few extra notes:</p>
<ul class="simple">
<li><p>All angles are in radians and distance units in microns. “Angle” refers to a rotation of the entire component from the default orientation.</p></li>
<li><p>Implied view is top-down on the x-y plane, looking along the negative z-axis. Geometry references to “width” correspond
to the pre-rotated x-dimension, “length” correspond to the pre-rotated y-dimension, and height/thickness correspond to the z-dimension.
For resonators “Length” instead corresponds to the actual length of the CPW (including the extra length due to the end pads).</p></li>
<li><p>JJ Location must be specified as “[x:y]” (without the quotations). Here x is the shift to the right and y is the shift up of the normalized JJ location.</p></li>
<li><p>Section Code is how the path of the control line meander is specified. It is best explained by example. Consider (S:100)(R:-1.5708:100)(S:1900)(R:3.14159:100)
This corresponds to a straight segment (“S”) of length 100um, followed by a turn (“R”) of angle -pi/2 radians and turn radius of 100um followed by
a straight segment of length 1900um followed by a turn of angle pi and turn radius 100um. Any number of these parentheses-delimited S or R “codes”
can be strung together to generate an arbitrary meander.</p></li>
<li><p>All meander turn radii must be greater than twice the mesh boundary parameter or the meander’s meshPeripheryPolyLine will not be a well-defined polygon.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="simulations-calculations">
<h2>Simulations/Calculations<a class="headerlink" href="#simulations-calculations" title="Permalink to this headline">¶</a></h2>
<p>The currently available models can be found in the simulations.py and calculations.py files.</p>
<p>The NIST quantization model involves running the following analyses in order:</p>
<ul class="simple">
<li><p>CapMat</p></li>
<li><p>LumpedR(i) for each readout resonator index</p></li>
<li><p>CapMatGE</p></li>
<li><p>ECQ(i) for each qubit index</p></li>
<li><p>ECR(i) for each readout resonator index</p></li>
<li><p>L_iQ(i) for each qubit index (to verify consistency of L_i in componentParams)</p></li>
<li><p>Quantize</p></li>
</ul>
<p>The following calculations are also available for convenience:</p>
<ul class="simple">
<li><p>ZZQ_Calc</p></li>
<li><p>anharmonicityQ</p></li>
<li><p>dispersiveShiftR</p></li>
</ul>
</div>
</div>
<div class="section" id="license">
<h1>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h1>
<p>This software package was developed Colorado School of Mines and the National Institute of Standards and Technology in Boulder, CO.
It is free for public use with proper credit/attribution.</p>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Joel Howard.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>